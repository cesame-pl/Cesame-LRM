\documentclass[11pt,A4]{article}

\usepackage{listings}
\usepackage[table]{xcolor}
\usepackage{xcolor}
\usepackage {color}
\usepackage[margin=1.2in]{geometry}
\usepackage{parskip}
\usepackage{threeparttable}
\usepackage{graphicx}
\usepackage{amsmath, amsfonts, amsthm}
\usepackage{booktabs}

\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 
\newcommand{\todo}[1]{\textcolor{red}{#1}}

\definecolor{gray}{RGB}{211, 211, 211}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.82}

% \lstset{
%     language=C,
%     backgroundcolor=\color{gray!25!white},
%     showstringspaces=false,
%     breaklines=true,
%     basicstyle=\ttfamily,
%     xleftmargin=10mm,
%     xrightmargin=10mm,
%     framexleftmargin=10mm,
%     framexrightmargin=10mm,
% }

\lstset{frame=tb,
	language=c, % 使用的语言
	aboveskip=3mm,
	belowskip=3mm,
	showstringspaces=false, % 仅在字符串中允许空格
	backgroundcolor=\color{gray!25!white},   % 选择代码背景，必须加上\ usepackage {color}或\ usepackage {xcolor}
	columns=flexible,
	basicstyle = \ttfamily\small,
	% frame = shadowbox,  
	numbers=left, % 给代码添加行号，可取值none, left, right.
	numberstyle=\small \color{gray},  % 行号的字号和颜色
	keywordstyle=\color{blue},
	commentstyle=\color{dkgreen}, % 设置注释格式
	stringstyle=\color{mauve},
	breaklines=true,   % 设置自动断行.
	breakatwhitespace=true, % 设置是否当且仅当在空白处自动中断.
	escapeinside=``, %逃逸字符(1左面的键)，用于显示中文
	% frame=shadowbox, %设置边框格式
	extendedchars=false, %解决代码跨页时，章节标题，页眉等汉字不显示的问题
	xleftmargin=2em,xrightmargin=2em, aboveskip=1em, %设置边距
	tabsize=4 % 将默认tab设置为4个空格
}

\title{
    \normalfont \LARGE
    \horrule{1pt} \\[0.4cm] 
    \huge The Cesame Programming Language \\
    \horrule{1pt} \\[0.6cm] 
    \textsc{Programming Language Reference Manual} \\ [25pt]
    % \Large IDK...Feel free to change (•‿•) \\[0.5cm]
}

\author{
   \begin{tabular}{ll}
       Language Guru: & Qian Zhao (qz2512) \\[5pt]
       System Architect: & Teng Jiang (tj2488) \\[5pt]
       Tester: & Yunjia Wang (yw4105)
   \end{tabular}
}
\date{}

\begin{document}

    \maketitle
    \thispagestyle{plain}
    \newpage
    
    \tableofcontents
    
    \newpage
    \section{Introduction}
    Your introduction content goes here.

    \newpage
    \section{Lexical Elements}
    
        \subsection{Identifiers}
        Identifiers are unique names given to various program elements such as variables, functions or arrays. Here are the naming rules:
        \begin{itemize}
            \item Case sensitive
            \item Begin with a letter or an underscore character
            \item Consist of only letters, digits, or underscore
            \item Cannot be a keyword
            \item Cannot contain white space
        \end{itemize}
        
        \subsection{Keywords}
        \todo{Fill Functions keywords in}
        \begin{center}
            \begin{tabular}{ c c c c c c c c }
            true & false \\
            new & delete \\ 
            void & bool & int & float & char & String & struct & Array \\
            if & else & for & while & goto & break & continue & return \\
            printf \\ 
            \end{tabular}
        \end{center}
        
        \subsection{Separators}
        A separator is used to separate tokens, including \texttt{white\_space} \texttt{( )} \texttt{\{ \}} \texttt{;} \texttt{,} \texttt{.} \texttt{:}

        \subsection{Operators}
        See the section "Expression and Operators"
        
        \subsection{White Space}
        White space in Cesame refers to characters that are used for formatting, such as spaces, tabs, and newline characters. White space is primarily used to enhance code readability and to separate tokens within a statement. 
        
        \subsection{Comment}
        Comments are non-executable lines used to document code and ignored by the compiler. There are two types of comments:
        \begin{itemize}
            \item Line comments
                \begin{lstlisting}
// line comments
                \end{lstlisting}
            \item General comments
                \begin{lstlisting}
/* General comments */
                \end{lstlisting}
        \end{itemize}

    \newpage
    \section{Data Types}
        \subsection{Primitive Data Types}
            \subsubsection{bool}
            \texttt{bool} can be either \texttt{true} or \texttt{false}. The logical operators can be applied to evaluate bool results.
            
            \subsubsection{int}
             \texttt{int} represents whole numbers, both positive and negative, without any fractional or decimal part. \texttt{int} occupies 4 bytes (32 bits) of memory, so its range is from -2,147,483,648 to 2,147,483,647.
            
            \subsubsection{float}
            \texttt{float} is a double-precision floating point number. It uses 8 bytes (64 bits) of memory and ranges from 1.7e-308 to 1.7e+308.
            
            \subsubsection{char}
            \input{char.tex}
            
        \subsection{Strings}
        \input{string.tex}
        
        \subsection{Structures}
        \input{struct.tex}
        
        \subsection{Arrays}
        \input{array.tex}

    \newpage
    \section{Expressions and Operators}
        
        \subsection{Operands}
        Operands are entities upon which operators act within expressions. They can be values, variables, constants, or the results of sub-expressions. For example, in the expression a + b, a and b are operands.
        
        \subsection{Unary Operators}
        Unary operators are operators in programming that operate on a single operand, meaning they work with only one operand or value. \\
        \begin{table}[h]
            \centering
            \setlength{\arrayrulewidth}{0.3mm}
            \renewcommand{\arraystretch}{1.2}
            \rowcolors{2}{gray!25}{white}
            \begin{tabular}{cccc}
                \toprule
                Symbol & Operator & Description & Example \\
                \midrule
                ++ & Increment & Increases the value of a variable by 1 & 
                \begin{tabular}[t]{@{}c@{}} 
                    \verb|int x = 5;| \\
                    \verb|x++;|
                \end{tabular} \\
                \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                - - & Decrement & Decreases the value of a variable by 1 & 
                \begin{tabular}[t]{@{}c@{}} 
                    \verb|int y = 10;| \\
                    \verb|y--;|
                \end{tabular} \\
                \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                + & Unary plus & Indicates a positive value & 
                \begin{tabular}[t]{@{}c@{}} 
                    \verb|int z = -5;| \\
                    \verb|int posZ = +z;|
                \end{tabular} \\
                \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                - & Unary minus & Negates the value of an expression & 
                \begin{tabular}[t]{@{}c@{}} 
                    \verb|int a = 8;| \\
                    \verb|int negA = -a;|
                \end{tabular} \\
                \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                ! & Logical NOT & Performs logical negation & 
                \begin{tabular}[t]{@{}c@{}} 
                    \verb|int isTrue = 1;| \\
                    \verb|int isFalse = !isTrue;|
                \end{tabular} \\
                \bottomrule
            \end{tabular}
        \end{table}  \\ 
        
        \subsection{Binary Operators}
        Binary operators are operators in programming that require two operands to perform an operation. 
            \newpage
            \subsubsection{Arithmetic Operators} 
            Perform mathematical calculations on numeric values.
            \begin{table}[h]
                \centering
                \setlength{\arrayrulewidth}{0.3mm}
                \renewcommand{\arraystretch}{1.2}
                \rowcolors{2}{gray!25}{white}
                \begin{tabular}{cccc}
                    \toprule
                    Symbol & Operator & Description & Example \\
                    \midrule
                    + & Addition & Adds two operands & \verb|int x1 = 5 + 3;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    - & Subtraction & Subtracts second operand from the first & \verb|int x2 = 7 - 2;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    * & Multiplication & Multiplies two operands & \verb|int x3 = 4 * 6;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    / & Division & Divides first operand by the second & \verb|float x4 = 10.0 / 2.0;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    \% & Modulus & Returns the remainder of the division & \verb|int x5 = 10 % 3;| \\
                    \bottomrule
                \end{tabular}
            \end{table} 
            
            \subsubsection{Comparison Operators}
            Compare two values and determine the relationship between them.
            \begin{table}[h]
                \centering
                \setlength{\arrayrulewidth}{0.3mm}
                \renewcommand{\arraystretch}{1.2}
                \rowcolors{2}{gray!25}{white}
                \begin{tabular}{ccc}
                    \toprule
                    Symbol & Operator & Description \\
                    \midrule
                    == & Equal to & Checks if two operands are equal \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    != & Not equal to & Checks if two operands are not equal \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    > & Greater than & Checks if first operand is greater than second \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    < & Less than & Checks if first operand is less than second \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    >= & Greater than or equal to & Checks if first operand is greater than or equal to second \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    <= & Less than or equal to & Checks if first operand is less than or equal to second \\
                    \bottomrule
                \end{tabular}
            \end{table}  
                        
            \subsubsection{Logical Operators} 
            Perform logical operations on boolean values.
            \begin{table}[h]
                \centering
                \setlength{\arrayrulewidth}{0.3mm}
                \renewcommand{\arraystretch}{1.2}
                \rowcolors{2}{gray!25}{white}
                \begin{tabular}{cccc}
                    \toprule
                    Symbol & Operator & Description & Example \\
                    \midrule
                    \&\& & Logical AND & Returns true if both operands are true & \verb|a && b| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    || & Logical OR & Returns true if either operand is true & \verb|x| || \verb|y| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    ! & Logical NOT & Inverts the truth value of its operand & \verb|!a| \\
                    \bottomrule
                \end{tabular}
            \end{table} 
            
            \subsubsection{Bitwise Operators}
            Perform operations at the bit level.
            \begin{table}[h]
                \centering
                \setlength{\arrayrulewidth}{0.3mm}
                \renewcommand{\arraystretch}{1.2}
                \rowcolors{2}{gray!25}{white}
                \begin{tabular}{cccc}
                    \toprule
                    Symbol & Operator & Description & Example \\
                    \midrule
                    \& & Bitwise AND & Performs bitwise AND on each pair of bits & \verb|a & b| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    | & Bitwise OR & Performs bitwise OR on each pair of bits & \verb|x| | \verb|y| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    $\wedge$ & Bitwise XOR & Performs bitwise XOR on each pair of bits & \verb|p ^ q| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    $\sim$ & Bitwise NOT & Inverts all the bits & \verb|~a;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    $<<$ & Left shift & Shifts bits to the left & \verb|x << 2| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-4}\arrayrulecolor{black}
                    $>>$ & Right shift & Shifts bits to the right & \verb|y >> 3| \\
                    \bottomrule
                \end{tabular}
            \end{table} 
            
            \subsubsection{Assignment Operators}
            Assign values to variables.
            \begin{table}[h]
                \centering
                \setlength{\arrayrulewidth}{0.3mm}
                \renewcommand{\arraystretch}{1.2}
                \rowcolors{2}{gray!25}{white}
                \begin{tabular}{ccc}
                    \toprule
                    Symbol & Operator & Example \\
                    \midrule
                    = & Assignment & \verb|int x = 5;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    += & Addition assignment & \verb|x += 3;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    -= & Subtraction assignment & \verb|x -= 2;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    *= & Multiplication assignment & \verb|x *= 4;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    /= & Division assignment & \verb|x /= 2;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    \%= & Modulus assignment & \verb|x \% = 3;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    <<= & Left shift assignment & \verb|x <<= 2;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    >>= & Right shift assignment & \verb|x >>= 3;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    \&= & Bitwise AND assignment & \verb|x \&= y;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    |= & Bitwise OR assignment & \verb|x| |= \verb|y;| \\
                    \arrayrulecolor{gray!50}\cmidrule(lr){1-3}\arrayrulecolor{black}
                    $\wedge$= & Bitwise XOR assignment & \verb|x ^= y;| \\
                    \bottomrule
                \end{tabular}
            \end{table}

        \subsection{Ternary Operators}
        \begin{lstlisting}
        condition ? expression1 : expression2;
        \end{lstlisting}
        The condition is a boolean expression that results in either true or false. If the condition is 
        \begin{itemize}
            \item \textbf{true}: expression1 is executed
            \item \textbf{false}: expression2 is executed
        \end{itemize}

        \subsection{Expressions}
        An expression is a combination of values, variables, operators, and function calls that evaluates to a single value. It can be as simple as a single variable or value, or it can be complex, involving multiple operations. \\

        Expressions may include:
        \begin{itemize}
            \item \textbf{Literals}: Constants such as numbers, characters, or strings.
                \begin{itemize}
                    \item \texttt{int num = 10;}
                    \item \texttt{char ch = 'A';}
                    \item \texttt{String s = "Hello";}
                \end{itemize}
                
            \item \textbf{Variables}: Named storage locations that hold values.
                \begin{itemize}
                    \item \texttt{int a = 5;}
                    \item \texttt{float b = 3.14;}
                    \item \texttt{char ch = 'B';}
                \end{itemize}
                
            \item \textbf{Operators}: Symbols representing computations such as addition, subtraction, division, etc.
                \begin{itemize}
                    \item \texttt{int sum = 5 + 3;} 
                    \item \texttt{int diff = 7 - 2;}
                    \item \texttt{float div = 10.0 / 2.0;}
                \end{itemize}
                
            \item \textbf{Function Calls}: Invocations of functions that return values.
                \begin{itemize}
                    \item \texttt{int minVal = min(10, 20);}
                    \item \texttt{int absValue = abs(-5);}
                    \item \texttt{float sqrtValue = sqrt(25.0);}
                \end{itemize}
        \end{itemize}

        \subsection{Operator Precedence and Associativity}
        The operators are grouped according to the rules of precedence when an expression contains multiple operators. The following list shows types of expressions presented in order of highest precedence first. For the operators of the same precedence, its associativity is left to right unless stated otherwise.
        \begin{enumerate}
            \item Array subscription, function calls, and membership accesses
            \item Unary operators. When multiple unary operators are consecutive, the later ones are nested in the earlier ones: !-a means !(-a)
            \item Multiplication, division, and modular expressions
            \item Addition and subtraction expressions
            \item Bitwise shifting expressions
            \item >=, <=, >, < expressions
            \item ==, != expressions
            \item Bitwise AND expressions
            \item Bitwise XOR expressions
            \item Bitwise OR expressions
            \item Logical AND expressions
            \item Logical OR expressions
            \item Ternary expressions
            \item Assignment expressions. Multiple assignment statements are evaluated from right to left. 
        \end{enumerate}

    \newpage
    \section{Statements}
        \subsection{Blocks}
        A block statement is a group of possibly empty statements enclosed in curly braces. Blocks serve several important purposes including grouping statements, scoping and variable lifetime, conditional execution, and code isolation.
        \begin{lstlisting}
Func print_val() -> int {
    // Block begins
    {
        int a = 5;
        printf("Value of a: %d\n", a);
    }
    // Block ends

    return 0;
}
        \end{lstlisting}
        
        \subsection{The Empty Statements}
        An empty statement does not do anything and is merely a semicolon alone. Mostly, an empty statement is used as the body of a loop statement. It is also used to follow a label that would otherwise be the last statement in a block. 
        \begin{lstlisting}
        for (int i = 0; i < 10; i++)
            ;
        \end{lstlisting}
        
        \subsection{Labeled Statement}
        Labels are identifiers followed by a colon, used to mark a position within the code. These labeled positions can be targeted by control flow statements such as `goto`, `break`, and `continue`. A labeled statement is a statement followed by a label.\\ \\
        Here's the general syntax for a labeled statement:
        \begin{lstlisting}
        label_name: statement
        \end{lstlisting}
        
        \subsection{Expression Statements}
        An expression statement is a statement that consists of an expression. Expression statements are only useful for their side effects, such as modifying variables, calling functions, or performing input/output operations.
        \begin{lstlisting}
// Function call is an expression statement
printf("Hello, world!\n");
        \end{lstlisting}

        \subsection{Declaration statements}
        A declaration statement introduces a new identifier (variable or function name) to the program. It specifies the type of the identifier and optionally initializes it with a value.
        \begin{lstlisting}
int x; // Declaration of variable x of type int
        \end{lstlisting}

        \subsection{Assignment statements}
        An assignment statement assigns a value to an already declared variable.
        \begin{lstlisting}
x = 10; // Assignment of the value 10 to the variable x
int y = x + 5;  // Declaration and assignment combined
        \end{lstlisting}
        
        \subsection{The \texttt{if} Statement}
        The \texttt{if} statement is a flow control statement used for executing a block of code conditionally.
        \begin{itemize}
            \item \textbf{\texttt{if} Statement}
            \begin{lstlisting}
if (condition) {
   // code to be executed if the condition is true
}
            \end{lstlisting}
            
            \item \textbf{\texttt{if-else} Statement}
            \begin{lstlisting}
if (condition) {
    // code executed when the condition is true
} else {
    // code executed when the condition is false
}
            \end{lstlisting}

            \item \textbf{\texttt{if-else-if} Ladder}
            \begin{lstlisting}
if (condition1) {
    // code executed when  condition1 is true
} else if (condition2) { 
    // code executed when condition1 is false and condition2 is true
} else {
    // code executed when both condition1 and condition2 are false
}
            \end{lstlisting}
        \end{itemize}
        
        \subsection{The \texttt{while} Statement}
        The \texttt{while} statement is a control flow statement that repeatedly executes a block of code as long as a specified condition is true.
        \begin{lstlisting}
while (condition) {
    // Code block to be executed repeatedly
}
        \end{lstlisting}
        
        \subsection{The \texttt{for} Statement}
        The \texttt{for} statement is a versatile control flow statement used for iterative execution. It allows you to execute a block of code repeatedly, with precise control over the iteration process. 
        \begin{lstlisting}
for (initialization; condition; step) {
    // Code block to be executed repeatedly
}
        \end{lstlisting}
        
        \subsection{The \texttt{goto} Statement}
        The \texttt{goto} statement is a control flow statement that allows you to transfer program control to a labeled statement within the same function.
        \begin{lstlisting}
goto label;
        \end{lstlisting}
    
        \subsection{The \texttt{break} Statement}
        the \texttt{break} statement is a control flow statement used to terminate the execution of a loop or switch statement prematurely.
        \begin{lstlisting}
break;
        \end{lstlisting}
        
        \subsection{The \texttt{continue} Statement}
        The \texttt{continue} statement is a control flow statement used to skip the current iteration of a loop and proceed to the next iteration. 
        \begin{lstlisting}
continue;
        \end{lstlisting}
        
        \subsection{The \texttt{return} Statement}
        The \texttt{return} statement is used to terminate the execution of a function and return a value to the calling code.
        \begin{lstlisting}
return <expression>;
        \end{lstlisting}

    \newpage
    \section{Functions}
        Functions are considered "first-class citizens" in Cesame, which means that a function can be assigned to variables, passed as arguments to other functions, and returned from other functions. Just like other non-primitive types in Cesame, we can declare and define a function object. However, Cesame employs a different syntax for function definition compared to C, reflecting its unique design principles.

        \subsection{Function Declaration}
            Functions in Cesame accept zero or more parameters as inputs and return zero or one output. A named function is characterized by the function name and the types of its inputs and output. An anonymous function is only characterized by the types of its inputs and output.


The types of inputs and output are specified in the bracket $<>$ followed by "Func", and separated with ",". There has to be at least one element in the bracket. The last element should be either a type specifying the output type, or the void keyword indicating that we output type. "void" keywords that are not the last element are ignored.

        \begin{lstlisting}
/* f1 takes in 2 integers and returns an integer. */
Func<int, int, int> f1;

/* f2_1 takes in nothing and returns an integer. */
Func<int> f2_1; 

/* void ignored, equivalent with f2_1 */
Func<void, int> f2_2;

/* f3 takes in an integer and returns nothing */
Func<int, void> f3; 

/* Functions can both be inputs and outputs and also can take in and return non-primitive types. */
Func<Func<String, Array<int>>, Func<String>> f4;
        \end{lstlisting}
        
        \subsection{Function Definitions}

An anonymous function is defined using the following syntax.

\begin{lstlisting}
/* An anonymous function that increments an integer */
(int x)->int { return x + 1 }; 

/* An anonymous function prints a string but does not return anything */
(String s)->void { s.print(); }

/* An anonymous function that does not take in anything, just returns 42 */
(String s)->int { return 42; }
\end{lstlisting}

There are 3 ways to define a function: 

Firstly, by using the "new" keyword we provide just like what we do with another non-primitive type. Notice that because the type is going to be able to be inferred from the definition, we can just use "new Func" instead of "new Func<...>", because the type is specified later in the body of the definition. This is the first kind of type inference allowed in functions.

\begin{lstlisting}
Func<int, int> inc;
inc = new Func (int i)-> int { return i + 1; };
\end{lstlisting}


If you declare and define a function together, the input and output types can also be inferred.

\begin{lstlisting}
Func inc = new Func (int i)-> int { return i + 1; };
\end{lstlisting}




Secondly, by using the "function" keyword (a syntactic sugar) we provide, you can declare and define a function together, similar to the syntax in C.
\begin{lstlisting}
function inc (int i)-> int { return i + 1; };
Func<int, int> inc (int i)-> int { return i + 1; };
\end{lstlisting}

Thirdly, you can define a function with a defined function, using "=", with LHS being the undefined function and RHS being a defined function. Notice that here "=" is definition, not assignment.
\begin{lstlisting}
/* Function declared, but not defined */
Func<int, int> inc, dec;

function another_dec (int i)-> int { return i - 1; }

/* inc is defined with a lambda function */
inc = (int i)->int { return i + 1 }; 

/* dec is defined with a named function another_dec */
dec = another_dec;


\end{lstlisting}



% Define an anonymous
% Define a named function: We can assign an unnamed function to it, or use the syntactic sugar we provided.
% Do we allow assigning a named function to a named function? (reference cnt += 1?)
% We also provide a syntactic sugar that. Here, the type of function f can be inferred, from the type of the anonymous function.

        
        
\subsection{Calling Functions}
Calling a function or in the sense of first-class functions evaluating a function, has a similar syntax with C.
\begin{lstlisting}
Func inc = new Func (int i)->int { return i + 1; };
int a = inc(a);
\end{lstlisting}

\subsection{Assign Functions}
Lastly, a defined function (named or anonymous) can be assigned to a defined named function.

\begin{lstlisting}
Func inc = new Func (int i)->int { return i + 1; };
Func another_inc = new Func (int i)->int { return i + 1; };

/* assign a named function to inc */
inc = another_inc;

/* assign a lambda function to inc */
inc = (int i)->int { return i + 1; };

\end{lstlisting}
        
        % \subsection{Function Parameters}
        % Content for function parameters.
        
        % \subsection{Higher-Order Functions}
        % Content for higher-order functions.

    \newpage
    \section{Sample Program}
    Content for sample program.

    \newpage
    \section{References}
    Content for reference.

\subsection{Assigning Functions}
Lambda function can not be assigned to. Ass
    
\end{document}
